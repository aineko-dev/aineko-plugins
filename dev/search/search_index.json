{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction to plugins","text":"<p>Aineko comes with a set of optional plugins that can be added to your pipeline. Currently these plugins are extra nodes with a focus on popular use-cases and best-practice patterns. To use one of these nodes, simply add it to your dependencies and reference it in the pipeline configuration.</p>"},{"location":"#adding-dependencies","title":"Adding Dependencies","text":"<p>To add a plugin to your pipeline, you need to install it as a dependency. If you already have an Aineko project, you can add the plugin by executing <code>poetry add aineko-plugins-plugin-name</code>. For example to add the <code>fastapi-server</code> node, you would run <code>poetry add aineko-plugins-nodes-fastapi-server</code>.</p>"},{"location":"#reference-in-pipeline-configuration","title":"Reference in Pipeline Configuration","text":"<p>To use such a node, simply reference the class in your pipeline configuration.</p> <p>:     pipeline.yml<pre><code>nodes:\n  fastapi:\n    class: aineko_plugins.nodes.fastapi_server.FastAPI\n    inputs:\n      - test_sequence\n    node_params:\n      app: my_awesome_pipeline.fastapi:app\n      port: 8000\n</code></pre></p> <p>Refer to the in-depth pages on each extra node for more detail on how to use them.</p>"},{"location":"nodes/fastapi-server/","title":"FastAPI Node","text":""},{"location":"nodes/fastapi-server/#installation","title":"Installation","text":"<p>The FastAPI plugin can be installed using poetry with the following command <code>poetry add aineko-plugins-nodes-fastapi-server</code>.</p>"},{"location":"nodes/fastapi-server/#api-reference","title":"API Reference","text":""},{"location":"nodes/fastapi-server/#aineko_plugins.nodes.fastapi_server.FastAPI","title":"aineko_plugins.nodes.fastapi_server.FastAPI","text":"<p>             Bases: <code>AbstractNode</code></p> <p>Node for creating a FastAPI app with a gunicorn server.</p> <p><code>node_params</code> should contain the following keys:</p> <pre><code>app: path to FastAPI app\nport (optional): port to run the server on. Defaults to 8000.\nlog_level (optional): log level to log messages from the uvicorn server.\n    Defaults to \"info\".\n</code></pre> <p>To access the consumers and producers from your FastAPI app, import the <code>consumers</code> and <code>producers</code> variables from <code>aineko_plugins.nodes.fastapi_server</code>. Use them as you would use <code>self.consumers</code> and <code>self.producers</code> in a regular node.</p> <p>We recommend no more than 1 FastAPI node per pipeline since the Consumer and Producer objects are namespaced at the pipeline level.</p> <p>Example usage in pipeline.yml: pipeline.yml<pre><code>pipeline:\n  nodes:\n    fastapi:\n      class: aineko_plugins.nodes.fastapi_server.FastAPI\n      inputs:\n        - test_sequence\n      node_params:\n        app: my_awesome_pipeline.fastapi:app\n        port: 8000\n</code></pre> where the app points to a FastAPI app. See FastAPI documentation on how to create a FastAPI app.</p> <p>Example usage in FastAPI app: fastapi.py<pre><code>from aineko_plugins.nodes.fastapi_server import consumers, producers\n\n@app.get(\"/query\")\nasync def query():\n    msg = consumers[\"test_sequence\"].next()\n    return msg\n</code></pre></p>"},{"location":"nodes/fastapi-server/#health-check-endpoint","title":"Health Check Endpoint","text":"<p>A common use case with an API server is to check its operational health status. For Aineko specifically, it is useful to know if the pipeline and API node are operational as well. Aineko comes with a light weight helper function as follows:</p>"},{"location":"nodes/fastapi-server/#aineko_plugins.nodes.fastapi_server.health.read_health","title":"aineko_plugins.nodes.fastapi_server.health.read_health  <code>async</code>","text":"<pre><code>read_health() -&gt; dict\n</code></pre> <p>Return the health status of the Aineko FastAPI server.</p> <p>Health router can be imported by an Aineko FastAPI server and added to the app as a router.</p> <p>The health check endpoint is available via a GET request to the <code>/health</code> route and returns a 200 response if the server is active.</p> <p>For example, if the FastAPI app is running locally on <code>http://localhost:8000</code>, the health check endpoint can be accessed via a GET request query to <code>http://localhost:8000/health</code>.</p> Example usage in FastAPI app <pre><code>from fastapi import FastAPI\nfrom aineko_plugins.nodes.fastapi_server import health_router\n\napp = FastAPI()\napp.include_router(health_router)\n</code></pre> Source code in <code>nodes/aineko-plugins-nodes-fastapi-server/aineko_plugins/nodes/fastapi_server/health.py</code> <pre><code>@health_router.get(\"/health\", status_code=200)\nasync def read_health() -&gt; dict:\n    \"\"\"Return the health status of the Aineko FastAPI server.\n\n    Health router can be imported by an Aineko FastAPI server and added\n    to the app as a router.\n\n    The health check endpoint is available via a GET request to the `/health`\n    route and returns a 200 response if the server is active.\n\n    For example, if the FastAPI app is running locally on\n    `http://localhost:8000`, the health check endpoint can be accessed via\n    a GET request query to `http://localhost:8000/health`.\n\n    Example usage in FastAPI app:\n        ```python hl_lines=\"2 5\"\n        from fastapi import FastAPI\n        from aineko_plugins.nodes.fastapi_server import health_router\n\n        app = FastAPI()\n        app.include_router(health_router)\n        ```\n    \"\"\"\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"nodes/fastapi-server/#authentication-considerations","title":"Authentication Considerations","text":"<p>By default, the <code>/health</code> endpoint does not contain authentication.</p> <p>One method to add authentication is to use security middleware at the app level for FastAPI. This will handle adding authentication to the health endpoint without having to add custom dependencies.</p> <p>For more information about security with FastAPI, check out the documentation here.</p>"},{"location":"nodes/http-poller/","title":"HTTPPoller Node","text":"<p>The HTTPPoller plugin can be installed using poetry with the following command <code>poetry add aineko-plugins-nodes-http-poller</code>.</p>"},{"location":"nodes/http-poller/#api-reference","title":"API Reference","text":""},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.HTTPPoller","title":"aineko_plugins.nodes.http_poller.http_poller.HTTPPoller","text":"<p>             Bases: <code>AbstractNode</code></p> <p>Connects to an endpoint via HTTP or HTTPS and polls.</p> <p>This node is a wrapper around the requests library.</p> <p>Example usage in pipeline.yml: pipeline.yml<pre><code>pipeline:\n  nodes:\n    HTTPPoller:\n      class: aineko_plugins.nodes.http_poller.HTTPPoller\n      outputs:\n        - test_http\n      node_params:\n        url: \"https://example.com\"\n        headers:\n          auth: \"Bearer {$SECRET_NAME}\"\n        data: {\"Greeting\": \"Hello, world!\"}\n</code></pre></p> <p>Secrets can be injected (from environment) into the <code>url</code>, <code>headers</code>, and <code>data</code> fields by passing a string with the following format: <code>{$SECRET_NAME}</code>. For example, if you have an environment variable named <code>SECRET_NAME</code>that contains the value <code>SECRET_VALUE</code>, you can inject it into the url field by passing <code>https://example.com?secret={$SECRET_NAME}</code> as the url. The connector will then replace <code>{$SECRET_NAME}</code> with <code>SECRET_VALUE</code> before connecting to the HTTP endpoint.</p> <p>Note that the <code>outputs</code> field is required and must contain exactly one output dataset. The output dataset will contain the data returned by the endpoint.</p> <p>By default, this node will poll the endpoint every 5 seconds and timeout after 10 seconds. If the request fails, it will retry every 5 seconds forever. Status codes in the 200s are considered success codes and no headers, data, auth, params, or json will be attached to the request.</p>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.HTTPPoller.last_poll_time","title":"last_poll_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_poll_time = time()\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.HTTPPoller.retry_count","title":"retry_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_count = 0\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.HTTPPoller.parse_data","title":"parse_data","text":"<pre><code>parse_data(raw_data: str) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Parses raw endpoint response using JSON parser.</p> <p>Parameters:</p> Name Type Description Default <code>raw_data</code> <code>str</code> <p>The raw unprocessed data returned by the endpoint. This is the result of calling <code>response.text</code> on the response object.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the retry count exceeds the max retries.</p> Source code in <code>nodes/aineko-plugins-nodes-http-poller/aineko_plugins/nodes/http_poller/http_poller.py</code> <pre><code>def parse_data(self, raw_data: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Parses raw endpoint response using JSON parser.\n\n    Args:\n        raw_data: The raw unprocessed data returned by the endpoint. This\n            is the result of calling `response.text` on the response object.\n\n    Raises:\n        Exception: If the retry count exceeds the max retries.\n    \"\"\"\n    try:\n        data = json.loads(raw_data)\n        if self.http_poller_params.metadata is not None:\n            data = {\n                \"metadata\": self.http_poller_params.metadata,\n                \"data\": data,\n            }\n        return data\n    except json.decoder.JSONDecodeError as err:\n        if self.retry_count &lt; self.http_poller_params.max_retries:\n            self.retry_count += 1\n            self.log(\n                f\"Failed to parse data: {raw_data}. \"\n                f\"The following error occurred: {err} \"\n                f\"Will retry in {self.http_poller_params.retry_sleep} \"\n                \"seconds...\",\n                level=\"error\",\n            )\n            time.sleep(self.http_poller_params.retry_sleep)\n            return None\n        else:\n            raise Exception(  # pylint: disable=broad-exception-raised\n                \"Retry count exceeded max retries \"\n                f\"({self.http_poller_params.max_retries}). \"\n                f\"Failed to parse data: {raw_data}. \"\n                f\"The following error occurred: {err}\"\n            ) from err\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.HTTPPoller.poll_endpoint","title":"poll_endpoint","text":"<pre><code>poll_endpoint() -&gt; Optional[str]\n</code></pre> <p>Polls the endpoint for data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the request fails.</p> Source code in <code>nodes/aineko-plugins-nodes-http-poller/aineko_plugins/nodes/http_poller/http_poller.py</code> <pre><code>def poll_endpoint(self) -&gt; Optional[str]:\n    \"\"\"Polls the endpoint for data.\n\n    Raises:\n        Exception: If the request fails.\n    \"\"\"\n    try:\n        # Poll the endpoint\n        response = self.session.get(\n            self.http_poller_params.url,\n            timeout=self.http_poller_params.timeout,\n            headers=self.http_poller_params.headers,\n            data=self.http_poller_params.data,\n            params=self.http_poller_params.params,\n            json=self.http_poller_params.json_,\n            auth=self.http_poller_params.auth,\n        )\n        # Check if the request was successful\n        if (\n            response.status_code\n            not in self.http_poller_params.success_codes\n        ):\n            # pylint: disable=broad-exception-raised\n            raise Exception(\n                f\"Request to url {self.http_poller_params.url} \"\n                \"failed with status code: \"\n                f\"{response.status_code}\"\n            )\n        return response.text\n    except Exception as err:  # pylint: disable=broad-except\n        # If request fails, log the error and sleep\n        self.log(\n            \"Request failed. \"\n            f\"Sleeping for {self.http_poller_params.retry_sleep} \"\n            f\"seconds. Error: {err}\",\n            level=\"error\",\n        )\n        time.sleep(self.http_poller_params.retry_sleep)\n        self.retry_count += 1\n        # Reset the session\n        self.log(\n            \"Creating new session to HTTP endpoint \"\n            f\"{self.http_poller_params.url}.\"\n        )\n        self.session = requests.Session()\n        return None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller","title":"aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller","text":"<pre><code>ParamsHTTPPoller(**data: Any)\n</code></pre> <p>             Bases: <code>BaseModel</code></p> <p>Parameters for the HTTPPoller node.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <code>int</code> <p>The number of seconds to wait for the endpoint to respond. Defaults to 10.</p> <code>url</code> <code>str</code> <p>The URL to connect to.</p> <code>headers</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary of headers to send to the endpoint. Defaults to None.</p> <code>data</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary of data to send to the endpoint. Defaults to None.</p> <code>params</code> <code>Optional[Union[Dict[str, Any], List[tuple], bytes]]</code> <p>A dictionary, list of tuples, bytes, or file-like object to send in the body of the request. Defaults to None.</p> <code>json_</code> <code>Optional[Dict[str, Any]]</code> <p>A JSON serializable Python object to send in the body of the request. Defaults to None.</p> <code>auth</code> <code>Optional[Tuple[str, str]]</code> <p>A tuple of username and password to use for Basic authentication. Defaults to None.</p> <code>poll_interval</code> <code>float</code> <p>The number of seconds to wait between polls. Defaults to 5.0.</p> <code>max_retries</code> <code>int</code> <p>The maximum number of times to retry connecting to the endpoint. Defaults to -1 (retry forever).</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary of metadata to attach to outgoing messages. Defaults to None.</p> <code>retry_sleep</code> <code>float</code> <p>The number of seconds to wait between retries. Defaults to 5.0.</p> <code>success_codes</code> <code>List[int]</code> <p>A list of status codes that indicate success. Defaults to [200, 201, 202, 203, 204, 205, 206, 207, 208, 226].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the url is not a valid HTTP or HTTPS URL.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:  # type: ignore\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    self.__pydantic_validator__.validate_python(data, self_instance=self)\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.auth","title":"auth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auth: Optional[Tuple[str, str]] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.json_","title":"json_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>json_: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.max_retries","title":"max_retries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_retries: int = -1\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Optional[\n    Union[Dict[str, Any], List[tuple], bytes]\n] = None\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.poll_interval","title":"poll_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>poll_interval: float = 5.0\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.retry_sleep","title":"retry_sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_sleep: float = 5\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.success_codes","title":"success_codes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>success_codes: List[int] = [\n    200,\n    201,\n    202,\n    203,\n    204,\n    205,\n    206,\n    207,\n    208,\n    226,\n]\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: int = 10\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"nodes/http-poller/#aineko_plugins.nodes.http_poller.http_poller.ParamsHTTPPoller.supported_url","title":"supported_url  <code>classmethod</code>","text":"<pre><code>supported_url(url: str) -&gt; str\n</code></pre> <p>Validates that the url is a valid HTTP or HTTPS URL.</p> Source code in <code>nodes/aineko-plugins-nodes-http-poller/aineko_plugins/nodes/http_poller/http_poller.py</code> <pre><code>@field_validator(\"url\")\n@classmethod\ndef supported_url(cls, url: str) -&gt; str:\n    \"\"\"Validates that the url is a valid HTTP or HTTPS URL.\"\"\"\n    if not (url.startswith(\"https://\") or url.startswith(\"http://\")):\n        raise ValueError(\n            \"Invalid url provided to HTTPPoller. \"\n            'Expected url to start with \"https://\" or \"http://\". '\n            f\"Provided url was: {url}\"\n        )\n    return url\n</code></pre>"},{"location":"nodes/websocket-client/","title":"WebSocketClient Node","text":"<p>The WebSocketClient plugin can be installed using poetry with the following command <code>poetry add aineko-plugins-nodes-websocket-client</code>.</p>"},{"location":"nodes/websocket-client/#api-reference","title":"API Reference","text":""},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.WebSocketClient","title":"aineko_plugins.nodes.websocket_client.WebSocketClient","text":"<p>             Bases: <code>AbstractNode</code></p> <p>Node for ingesting data from a WebSocket.</p> <p>This node is a wrapper around the websocket-client library.</p> <p><code>node_params</code> should be a dictionary with the following keys:</p> <pre><code>url: The WebSocket URL to connect to\nheader (optional): A dictionary of headers to send to the WebSocket.\n    Defaults to None.\ninit_messages (optional): A list of messages to send to the WebSocket\n    upon connection. Defaults to [].\nmetadata (optional): A dictionary of metadata to attach to outgoing\n    messages. Defaults to None.\nmax_retries (optional): The maximum number of times to retry\n    connecting to the WebSocket. Defaults to -1 (retry forever).\nretry_sleep (optional): The number of seconds to wait between retries.\n    Defaults to 5.\n</code></pre> <p>Secrets can be injected (from environment) into the <code>url</code>, <code>header</code>, and <code>init_messages</code> fields by passing a string with the following format: <code>{$SECRET_NAME}</code>. For example, if you have a secret named <code>SECRET_NAME</code> with value <code>SECRET_VALUE</code>, you can inject it into the url field by passing <code>wss://example.com?secret={$SECRET_NAME}</code> as the url. The connector will then replace <code>{$SECRET_NAME}</code> with <code>SECRET_VALUE</code> before connecting to the WebSocket.</p> <p>Example usage in pipeline.yml: pipeline.yml<pre><code>pipeline:\n  nodes:\n    WebSocketClient:\n      class: aineko_plugins.nodes.websocket_client.WebSocketClient\n      outputs:\n        - test_websocket\n      node_params:\n        url: \"wss://example.com\"\n        header:\n          auth: \"Bearer {$SECRET_NAME}\"\n        init_messages:\n            - {\"Greeting\": \"Hello, world!\"}\n</code></pre></p>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.WebSocketClient.retry_count","title":"retry_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_count = 0\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.WebSocketClient.create_subscription","title":"create_subscription","text":"<pre><code>create_subscription() -&gt; None\n</code></pre> <p>Creates a subscription on the websocket.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the retry count exceeds the max retries.</p> Source code in <code>nodes/aineko-plugins-nodes-websocket-client/aineko_plugins/nodes/websocket_client/websocket_client.py</code> <pre><code>def create_subscription(self) -&gt; None:\n    \"\"\"Creates a subscription on the websocket.\n\n    Raises:\n        ValueError: If the retry count exceeds the max retries.\n    \"\"\"\n    try:\n        self.log(f\"Creating subscription to {self.ws_params.url}...\")\n        self.ws.connect(\n            url=self.ws_params.url, header=self.ws_params.header\n        )  # type: ignore\n\n        if self.ws_params.init_messages:\n            # Send initialization messages\n            for init_msg in self.ws_params.init_messages:\n                self.ws.send(json.dumps(init_msg))\n                message = self.ws.recv()\n                self.log(\n                    \"Sent initialization message to \"\n                    f\"{self.ws_params.url}. \"\n                    f\"Acknowledged initialization message: {message!r}\"\n                )\n\n        ack_message = self.ws.recv()\n        self.log(\n            f\"Subscription to {self.ws_params.url} created. \"\n            f\"Acknowledged subscription message: {ack_message!r}\"\n        )\n\n        self.retry_count = 0\n    except Exception as err:  # pylint: disable=broad-except\n        if self.retry_count &lt; self.ws_params.max_retries:\n            self.log(\n                \"Encountered error when attempting to connect to \"\n                f\"{self.ws_params.url}. Will retry in \"\n                f\"{self.ws_params.retry_sleep} seconds\"\n            )\n            self.retry_count += 1\n            time.sleep(self.ws_params.retry_sleep)\n            self.create_subscription()\n        else:\n            raise ValueError(\n                \"Retry count exceeded max retries. \"\n                \"Failed to create subscription to \"\n                f\"{self.ws_params.url}. \"\n                f\"The following error occurred: {err}\"\n            ) from err\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient","title":"aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient","text":"<pre><code>ParamsWebSocketClient(**data: Any)\n</code></pre> <p>             Bases: <code>BaseModel</code></p> <p>Connector params for WebSocket model.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> Source code in <code>pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:  # type: ignore\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    self.__pydantic_validator__.validate_python(data, self_instance=self)\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.init_messages","title":"init_messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>init_messages: List[Any] = []\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.max_retries","title":"max_retries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_retries: int = -1\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.retry_sleep","title":"retry_sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_sleep: float = 5\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"nodes/websocket-client/#aineko_plugins.nodes.websocket_client.websocket_client.ParamsWebSocketClient.supported_url","title":"supported_url  <code>classmethod</code>","text":"<pre><code>supported_url(url: str) -&gt; str\n</code></pre> <p>Validates that the url is a valid WebSocket URL.</p> Source code in <code>nodes/aineko-plugins-nodes-websocket-client/aineko_plugins/nodes/websocket_client/websocket_client.py</code> <pre><code>@field_validator(\"url\")\n@classmethod\ndef supported_url(cls, url: str) -&gt; str:\n    \"\"\"Validates that the url is a valid WebSocket URL.\"\"\"\n    if not (url.startswith(\"wss://\") or url.startswith(\"ws://\")):\n        raise ValueError(\n            \"Invalid url provided to WebSocket params. \"\n            'Expected url to start with \"wss://\" or \"ws://\". '\n            f\"Provided url was: {url}\"\n        )\n    return url\n</code></pre>"}]}